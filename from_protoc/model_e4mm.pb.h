// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model_e4mm.proto

#ifndef PROTOBUF_model_5fe4mm_2eproto__INCLUDED
#define PROTOBUF_model_5fe4mm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_model_5fe4mm_2eproto();
void protobuf_AssignDesc_model_5fe4mm_2eproto();
void protobuf_ShutdownFile_model_5fe4mm_2eproto();

class E4mmConfig;
class E4mmState;
class E4mmState_Fields;
class E4mmState_Particles;
class E4mmStateGeneratorConfig;
class E4mmModel;
class E4mmSolution;

// ===================================================================

class E4mmConfig : public ::google::protobuf::Message {
 public:
  E4mmConfig();
  virtual ~E4mmConfig();

  E4mmConfig(const E4mmConfig& from);

  inline E4mmConfig& operator=(const E4mmConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E4mmConfig& default_instance();

  void Swap(E4mmConfig* other);

  // implements Message ----------------------------------------------

  E4mmConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E4mmConfig& from);
  void MergeFrom(const E4mmConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 N = 1;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 1;
  inline ::google::protobuf::uint32 n() const;
  inline void set_n(::google::protobuf::uint32 value);

  // required uint32 n0 = 2;
  inline bool has_n0() const;
  inline void clear_n0();
  static const int kN0FieldNumber = 2;
  inline ::google::protobuf::uint32 n0() const;
  inline void set_n0(::google::protobuf::uint32 value);

  // required uint32 k = 3;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 3;
  inline ::google::protobuf::uint32 k() const;
  inline void set_k(::google::protobuf::uint32 value);

  // required double beta = 4;
  inline bool has_beta() const;
  inline void clear_beta();
  static const int kBetaFieldNumber = 4;
  inline double beta() const;
  inline void set_beta(double value);

  // optional double alpha = 5;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 5;
  inline double alpha() const;
  inline void set_alpha(double value);

  // optional double s = 6;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 6;
  inline double s() const;
  inline void set_s(double value);

  // optional double gamma_omega = 7;
  inline bool has_gamma_omega() const;
  inline void clear_gamma_omega();
  static const int kGammaOmegaFieldNumber = 7;
  inline double gamma_omega() const;
  inline void set_gamma_omega(double value);

  // @@protoc_insertion_point(class_scope:pb.E4mmConfig)
 private:
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_n0();
  inline void clear_has_n0();
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_beta();
  inline void clear_has_beta();
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_gamma_omega();
  inline void clear_has_gamma_omega();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 n_;
  ::google::protobuf::uint32 n0_;
  double beta_;
  double alpha_;
  double s_;
  double gamma_omega_;
  ::google::protobuf::uint32 k_;
  friend void  protobuf_AddDesc_model_5fe4mm_2eproto();
  friend void protobuf_AssignDesc_model_5fe4mm_2eproto();
  friend void protobuf_ShutdownFile_model_5fe4mm_2eproto();

  void InitAsDefaultInstance();
  static E4mmConfig* default_instance_;
};
// -------------------------------------------------------------------

class E4mmState_Fields : public ::google::protobuf::Message {
 public:
  E4mmState_Fields();
  virtual ~E4mmState_Fields();

  E4mmState_Fields(const E4mmState_Fields& from);

  inline E4mmState_Fields& operator=(const E4mmState_Fields& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E4mmState_Fields& default_instance();

  void Swap(E4mmState_Fields* other);

  // implements Message ----------------------------------------------

  E4mmState_Fields* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E4mmState_Fields& from);
  void MergeFrom(const E4mmState_Fields& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double E = 3;
  inline bool has_e() const;
  inline void clear_e();
  static const int kEFieldNumber = 3;
  inline double e() const;
  inline void set_e(double value);

  // required double phi = 4;
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 4;
  inline double phi() const;
  inline void set_phi(double value);

  // @@protoc_insertion_point(class_scope:pb.E4mmState.Fields)
 private:
  inline void set_has_e();
  inline void clear_has_e();
  inline void set_has_phi();
  inline void clear_has_phi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double e_;
  double phi_;
  friend void  protobuf_AddDesc_model_5fe4mm_2eproto();
  friend void protobuf_AssignDesc_model_5fe4mm_2eproto();
  friend void protobuf_ShutdownFile_model_5fe4mm_2eproto();

  void InitAsDefaultInstance();
  static E4mmState_Fields* default_instance_;
};
// -------------------------------------------------------------------

class E4mmState_Particles : public ::google::protobuf::Message {
 public:
  E4mmState_Particles();
  virtual ~E4mmState_Particles();

  E4mmState_Particles(const E4mmState_Particles& from);

  inline E4mmState_Particles& operator=(const E4mmState_Particles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E4mmState_Particles& default_instance();

  void Swap(E4mmState_Particles* other);

  // implements Message ----------------------------------------------

  E4mmState_Particles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E4mmState_Particles& from);
  void MergeFrom(const E4mmState_Particles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double a = 5;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 5;
  inline double a() const;
  inline void set_a(double value);

  // required double psi = 6;
  inline bool has_psi() const;
  inline void clear_psi();
  static const int kPsiFieldNumber = 6;
  inline double psi() const;
  inline void set_psi(double value);

  // required double z = 7;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 7;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:pb.E4mmState.Particles)
 private:
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_psi();
  inline void clear_has_psi();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double a_;
  double psi_;
  double z_;
  friend void  protobuf_AddDesc_model_5fe4mm_2eproto();
  friend void protobuf_AssignDesc_model_5fe4mm_2eproto();
  friend void protobuf_ShutdownFile_model_5fe4mm_2eproto();

  void InitAsDefaultInstance();
  static E4mmState_Particles* default_instance_;
};
// -------------------------------------------------------------------

class E4mmState : public ::google::protobuf::Message {
 public:
  E4mmState();
  virtual ~E4mmState();

  E4mmState(const E4mmState& from);

  inline E4mmState& operator=(const E4mmState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E4mmState& default_instance();

  void Swap(E4mmState* other);

  // implements Message ----------------------------------------------

  E4mmState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E4mmState& from);
  void MergeFrom(const E4mmState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef E4mmState_Fields Fields;
  typedef E4mmState_Particles Particles;

  // accessors -------------------------------------------------------

  // repeated group Fields = 1 {
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 1;
  inline const ::pb::E4mmState_Fields& fields(int index) const;
  inline ::pb::E4mmState_Fields* mutable_fields(int index);
  inline ::pb::E4mmState_Fields* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Fields >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Fields >*
      mutable_fields();

  // repeated group Particles = 2 {
  inline int particles_size() const;
  inline void clear_particles();
  static const int kParticlesFieldNumber = 2;
  inline const ::pb::E4mmState_Particles& particles(int index) const;
  inline ::pb::E4mmState_Particles* mutable_particles(int index);
  inline ::pb::E4mmState_Particles* add_particles();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Particles >&
      particles() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Particles >*
      mutable_particles();

  // @@protoc_insertion_point(class_scope:pb.E4mmState)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Fields > fields_;
  ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Particles > particles_;
  friend void  protobuf_AddDesc_model_5fe4mm_2eproto();
  friend void protobuf_AssignDesc_model_5fe4mm_2eproto();
  friend void protobuf_ShutdownFile_model_5fe4mm_2eproto();

  void InitAsDefaultInstance();
  static E4mmState* default_instance_;
};
// -------------------------------------------------------------------

class E4mmStateGeneratorConfig : public ::google::protobuf::Message {
 public:
  E4mmStateGeneratorConfig();
  virtual ~E4mmStateGeneratorConfig();

  E4mmStateGeneratorConfig(const E4mmStateGeneratorConfig& from);

  inline E4mmStateGeneratorConfig& operator=(const E4mmStateGeneratorConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E4mmStateGeneratorConfig& default_instance();

  void Swap(E4mmStateGeneratorConfig* other);

  // implements Message ----------------------------------------------

  E4mmStateGeneratorConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E4mmStateGeneratorConfig& from);
  void MergeFrom(const E4mmStateGeneratorConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double E0 = 1;
  inline bool has_e0() const;
  inline void clear_e0();
  static const int kE0FieldNumber = 1;
  inline double e0() const;
  inline void set_e0(double value);

  // required double A0 = 2;
  inline bool has_a0() const;
  inline void clear_a0();
  static const int kA0FieldNumber = 2;
  inline double a0() const;
  inline void set_a0(double value);

  // @@protoc_insertion_point(class_scope:pb.E4mmStateGeneratorConfig)
 private:
  inline void set_has_e0();
  inline void clear_has_e0();
  inline void set_has_a0();
  inline void clear_has_a0();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double e0_;
  double a0_;
  friend void  protobuf_AddDesc_model_5fe4mm_2eproto();
  friend void protobuf_AssignDesc_model_5fe4mm_2eproto();
  friend void protobuf_ShutdownFile_model_5fe4mm_2eproto();

  void InitAsDefaultInstance();
  static E4mmStateGeneratorConfig* default_instance_;
};
// -------------------------------------------------------------------

class E4mmModel : public ::google::protobuf::Message {
 public:
  E4mmModel();
  virtual ~E4mmModel();

  E4mmModel(const E4mmModel& from);

  inline E4mmModel& operator=(const E4mmModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E4mmModel& default_instance();

  void Swap(E4mmModel* other);

  // implements Message ----------------------------------------------

  E4mmModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E4mmModel& from);
  void MergeFrom(const E4mmModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.E4mmConfig pconfig = 1;
  inline bool has_pconfig() const;
  inline void clear_pconfig();
  static const int kPconfigFieldNumber = 1;
  inline const ::pb::E4mmConfig& pconfig() const;
  inline ::pb::E4mmConfig* mutable_pconfig();
  inline ::pb::E4mmConfig* release_pconfig();
  inline void set_allocated_pconfig(::pb::E4mmConfig* pconfig);

  // required .pb.E4mmState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::pb::E4mmState& state() const;
  inline ::pb::E4mmState* mutable_state();
  inline ::pb::E4mmState* release_state();
  inline void set_allocated_state(::pb::E4mmState* state);

  // required .pb.EXPetscSolverConfig sconfig = 3;
  inline bool has_sconfig() const;
  inline void clear_sconfig();
  static const int kSconfigFieldNumber = 3;
  inline const ::pb::EXPetscSolverConfig& sconfig() const;
  inline ::pb::EXPetscSolverConfig* mutable_sconfig();
  inline ::pb::EXPetscSolverConfig* release_sconfig();
  inline void set_allocated_sconfig(::pb::EXPetscSolverConfig* sconfig);

  // @@protoc_insertion_point(class_scope:pb.E4mmModel)
 private:
  inline void set_has_pconfig();
  inline void clear_has_pconfig();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sconfig();
  inline void clear_has_sconfig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::E4mmConfig* pconfig_;
  ::pb::E4mmState* state_;
  ::pb::EXPetscSolverConfig* sconfig_;
  friend void  protobuf_AddDesc_model_5fe4mm_2eproto();
  friend void protobuf_AssignDesc_model_5fe4mm_2eproto();
  friend void protobuf_ShutdownFile_model_5fe4mm_2eproto();

  void InitAsDefaultInstance();
  static E4mmModel* default_instance_;
};
// -------------------------------------------------------------------

class E4mmSolution : public ::google::protobuf::Message {
 public:
  E4mmSolution();
  virtual ~E4mmSolution();

  E4mmSolution(const E4mmSolution& from);

  inline E4mmSolution& operator=(const E4mmSolution& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E4mmSolution& default_instance();

  void Swap(E4mmSolution* other);

  // implements Message ----------------------------------------------

  E4mmSolution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E4mmSolution& from);
  void MergeFrom(const E4mmSolution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.E4mmState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::pb::E4mmState& state() const;
  inline ::pb::E4mmState* mutable_state();
  inline ::pb::E4mmState* release_state();
  inline void set_allocated_state(::pb::E4mmState* state);

  // optional .pb.E4mmState d_state = 2;
  inline bool has_d_state() const;
  inline void clear_d_state();
  static const int kDStateFieldNumber = 2;
  inline const ::pb::E4mmState& d_state() const;
  inline ::pb::E4mmState* mutable_d_state();
  inline ::pb::E4mmState* release_d_state();
  inline void set_allocated_d_state(::pb::E4mmState* d_state);

  // @@protoc_insertion_point(class_scope:pb.E4mmSolution)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_d_state();
  inline void clear_has_d_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::E4mmState* state_;
  ::pb::E4mmState* d_state_;
  friend void  protobuf_AddDesc_model_5fe4mm_2eproto();
  friend void protobuf_AssignDesc_model_5fe4mm_2eproto();
  friend void protobuf_ShutdownFile_model_5fe4mm_2eproto();

  void InitAsDefaultInstance();
  static E4mmSolution* default_instance_;
};
// ===================================================================


// ===================================================================

// E4mmConfig

// required uint32 N = 1;
inline bool E4mmConfig::has_n() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E4mmConfig::set_has_n() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E4mmConfig::clear_has_n() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E4mmConfig::clear_n() {
  n_ = 0u;
  clear_has_n();
}
inline ::google::protobuf::uint32 E4mmConfig::n() const {
  // @@protoc_insertion_point(field_get:pb.E4mmConfig.N)
  return n_;
}
inline void E4mmConfig::set_n(::google::protobuf::uint32 value) {
  set_has_n();
  n_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmConfig.N)
}

// required uint32 n0 = 2;
inline bool E4mmConfig::has_n0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E4mmConfig::set_has_n0() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E4mmConfig::clear_has_n0() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E4mmConfig::clear_n0() {
  n0_ = 0u;
  clear_has_n0();
}
inline ::google::protobuf::uint32 E4mmConfig::n0() const {
  // @@protoc_insertion_point(field_get:pb.E4mmConfig.n0)
  return n0_;
}
inline void E4mmConfig::set_n0(::google::protobuf::uint32 value) {
  set_has_n0();
  n0_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmConfig.n0)
}

// required uint32 k = 3;
inline bool E4mmConfig::has_k() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E4mmConfig::set_has_k() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E4mmConfig::clear_has_k() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E4mmConfig::clear_k() {
  k_ = 0u;
  clear_has_k();
}
inline ::google::protobuf::uint32 E4mmConfig::k() const {
  // @@protoc_insertion_point(field_get:pb.E4mmConfig.k)
  return k_;
}
inline void E4mmConfig::set_k(::google::protobuf::uint32 value) {
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmConfig.k)
}

// required double beta = 4;
inline bool E4mmConfig::has_beta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void E4mmConfig::set_has_beta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void E4mmConfig::clear_has_beta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void E4mmConfig::clear_beta() {
  beta_ = 0;
  clear_has_beta();
}
inline double E4mmConfig::beta() const {
  // @@protoc_insertion_point(field_get:pb.E4mmConfig.beta)
  return beta_;
}
inline void E4mmConfig::set_beta(double value) {
  set_has_beta();
  beta_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmConfig.beta)
}

// optional double alpha = 5;
inline bool E4mmConfig::has_alpha() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void E4mmConfig::set_has_alpha() {
  _has_bits_[0] |= 0x00000010u;
}
inline void E4mmConfig::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void E4mmConfig::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline double E4mmConfig::alpha() const {
  // @@protoc_insertion_point(field_get:pb.E4mmConfig.alpha)
  return alpha_;
}
inline void E4mmConfig::set_alpha(double value) {
  set_has_alpha();
  alpha_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmConfig.alpha)
}

// optional double s = 6;
inline bool E4mmConfig::has_s() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void E4mmConfig::set_has_s() {
  _has_bits_[0] |= 0x00000020u;
}
inline void E4mmConfig::clear_has_s() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void E4mmConfig::clear_s() {
  s_ = 0;
  clear_has_s();
}
inline double E4mmConfig::s() const {
  // @@protoc_insertion_point(field_get:pb.E4mmConfig.s)
  return s_;
}
inline void E4mmConfig::set_s(double value) {
  set_has_s();
  s_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmConfig.s)
}

// optional double gamma_omega = 7;
inline bool E4mmConfig::has_gamma_omega() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void E4mmConfig::set_has_gamma_omega() {
  _has_bits_[0] |= 0x00000040u;
}
inline void E4mmConfig::clear_has_gamma_omega() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void E4mmConfig::clear_gamma_omega() {
  gamma_omega_ = 0;
  clear_has_gamma_omega();
}
inline double E4mmConfig::gamma_omega() const {
  // @@protoc_insertion_point(field_get:pb.E4mmConfig.gamma_omega)
  return gamma_omega_;
}
inline void E4mmConfig::set_gamma_omega(double value) {
  set_has_gamma_omega();
  gamma_omega_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmConfig.gamma_omega)
}

// -------------------------------------------------------------------

// E4mmState_Fields

// required double E = 3;
inline bool E4mmState_Fields::has_e() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E4mmState_Fields::set_has_e() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E4mmState_Fields::clear_has_e() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E4mmState_Fields::clear_e() {
  e_ = 0;
  clear_has_e();
}
inline double E4mmState_Fields::e() const {
  // @@protoc_insertion_point(field_get:pb.E4mmState.Fields.E)
  return e_;
}
inline void E4mmState_Fields::set_e(double value) {
  set_has_e();
  e_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmState.Fields.E)
}

// required double phi = 4;
inline bool E4mmState_Fields::has_phi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E4mmState_Fields::set_has_phi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E4mmState_Fields::clear_has_phi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E4mmState_Fields::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double E4mmState_Fields::phi() const {
  // @@protoc_insertion_point(field_get:pb.E4mmState.Fields.phi)
  return phi_;
}
inline void E4mmState_Fields::set_phi(double value) {
  set_has_phi();
  phi_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmState.Fields.phi)
}

// -------------------------------------------------------------------

// E4mmState_Particles

// required double a = 5;
inline bool E4mmState_Particles::has_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E4mmState_Particles::set_has_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E4mmState_Particles::clear_has_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E4mmState_Particles::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline double E4mmState_Particles::a() const {
  // @@protoc_insertion_point(field_get:pb.E4mmState.Particles.a)
  return a_;
}
inline void E4mmState_Particles::set_a(double value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmState.Particles.a)
}

// required double psi = 6;
inline bool E4mmState_Particles::has_psi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E4mmState_Particles::set_has_psi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E4mmState_Particles::clear_has_psi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E4mmState_Particles::clear_psi() {
  psi_ = 0;
  clear_has_psi();
}
inline double E4mmState_Particles::psi() const {
  // @@protoc_insertion_point(field_get:pb.E4mmState.Particles.psi)
  return psi_;
}
inline void E4mmState_Particles::set_psi(double value) {
  set_has_psi();
  psi_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmState.Particles.psi)
}

// required double z = 7;
inline bool E4mmState_Particles::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E4mmState_Particles::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E4mmState_Particles::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E4mmState_Particles::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double E4mmState_Particles::z() const {
  // @@protoc_insertion_point(field_get:pb.E4mmState.Particles.z)
  return z_;
}
inline void E4mmState_Particles::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmState.Particles.z)
}

// -------------------------------------------------------------------

// E4mmState

// repeated group Fields = 1 {
inline int E4mmState::fields_size() const {
  return fields_.size();
}
inline void E4mmState::clear_fields() {
  fields_.Clear();
}
inline const ::pb::E4mmState_Fields& E4mmState::fields(int index) const {
  // @@protoc_insertion_point(field_get:pb.E4mmState.fields)
  return fields_.Get(index);
}
inline ::pb::E4mmState_Fields* E4mmState::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:pb.E4mmState.fields)
  return fields_.Mutable(index);
}
inline ::pb::E4mmState_Fields* E4mmState::add_fields() {
  // @@protoc_insertion_point(field_add:pb.E4mmState.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Fields >&
E4mmState::fields() const {
  // @@protoc_insertion_point(field_list:pb.E4mmState.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Fields >*
E4mmState::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:pb.E4mmState.fields)
  return &fields_;
}

// repeated group Particles = 2 {
inline int E4mmState::particles_size() const {
  return particles_.size();
}
inline void E4mmState::clear_particles() {
  particles_.Clear();
}
inline const ::pb::E4mmState_Particles& E4mmState::particles(int index) const {
  // @@protoc_insertion_point(field_get:pb.E4mmState.particles)
  return particles_.Get(index);
}
inline ::pb::E4mmState_Particles* E4mmState::mutable_particles(int index) {
  // @@protoc_insertion_point(field_mutable:pb.E4mmState.particles)
  return particles_.Mutable(index);
}
inline ::pb::E4mmState_Particles* E4mmState::add_particles() {
  // @@protoc_insertion_point(field_add:pb.E4mmState.particles)
  return particles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Particles >&
E4mmState::particles() const {
  // @@protoc_insertion_point(field_list:pb.E4mmState.particles)
  return particles_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::E4mmState_Particles >*
E4mmState::mutable_particles() {
  // @@protoc_insertion_point(field_mutable_list:pb.E4mmState.particles)
  return &particles_;
}

// -------------------------------------------------------------------

// E4mmStateGeneratorConfig

// required double E0 = 1;
inline bool E4mmStateGeneratorConfig::has_e0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E4mmStateGeneratorConfig::set_has_e0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E4mmStateGeneratorConfig::clear_has_e0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E4mmStateGeneratorConfig::clear_e0() {
  e0_ = 0;
  clear_has_e0();
}
inline double E4mmStateGeneratorConfig::e0() const {
  // @@protoc_insertion_point(field_get:pb.E4mmStateGeneratorConfig.E0)
  return e0_;
}
inline void E4mmStateGeneratorConfig::set_e0(double value) {
  set_has_e0();
  e0_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmStateGeneratorConfig.E0)
}

// required double A0 = 2;
inline bool E4mmStateGeneratorConfig::has_a0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E4mmStateGeneratorConfig::set_has_a0() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E4mmStateGeneratorConfig::clear_has_a0() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E4mmStateGeneratorConfig::clear_a0() {
  a0_ = 0;
  clear_has_a0();
}
inline double E4mmStateGeneratorConfig::a0() const {
  // @@protoc_insertion_point(field_get:pb.E4mmStateGeneratorConfig.A0)
  return a0_;
}
inline void E4mmStateGeneratorConfig::set_a0(double value) {
  set_has_a0();
  a0_ = value;
  // @@protoc_insertion_point(field_set:pb.E4mmStateGeneratorConfig.A0)
}

// -------------------------------------------------------------------

// E4mmModel

// required .pb.E4mmConfig pconfig = 1;
inline bool E4mmModel::has_pconfig() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E4mmModel::set_has_pconfig() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E4mmModel::clear_has_pconfig() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E4mmModel::clear_pconfig() {
  if (pconfig_ != NULL) pconfig_->::pb::E4mmConfig::Clear();
  clear_has_pconfig();
}
inline const ::pb::E4mmConfig& E4mmModel::pconfig() const {
  // @@protoc_insertion_point(field_get:pb.E4mmModel.pconfig)
  return pconfig_ != NULL ? *pconfig_ : *default_instance_->pconfig_;
}
inline ::pb::E4mmConfig* E4mmModel::mutable_pconfig() {
  set_has_pconfig();
  if (pconfig_ == NULL) pconfig_ = new ::pb::E4mmConfig;
  // @@protoc_insertion_point(field_mutable:pb.E4mmModel.pconfig)
  return pconfig_;
}
inline ::pb::E4mmConfig* E4mmModel::release_pconfig() {
  clear_has_pconfig();
  ::pb::E4mmConfig* temp = pconfig_;
  pconfig_ = NULL;
  return temp;
}
inline void E4mmModel::set_allocated_pconfig(::pb::E4mmConfig* pconfig) {
  delete pconfig_;
  pconfig_ = pconfig;
  if (pconfig) {
    set_has_pconfig();
  } else {
    clear_has_pconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E4mmModel.pconfig)
}

// required .pb.E4mmState state = 2;
inline bool E4mmModel::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E4mmModel::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E4mmModel::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E4mmModel::clear_state() {
  if (state_ != NULL) state_->::pb::E4mmState::Clear();
  clear_has_state();
}
inline const ::pb::E4mmState& E4mmModel::state() const {
  // @@protoc_insertion_point(field_get:pb.E4mmModel.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::pb::E4mmState* E4mmModel::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::pb::E4mmState;
  // @@protoc_insertion_point(field_mutable:pb.E4mmModel.state)
  return state_;
}
inline ::pb::E4mmState* E4mmModel::release_state() {
  clear_has_state();
  ::pb::E4mmState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void E4mmModel::set_allocated_state(::pb::E4mmState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E4mmModel.state)
}

// required .pb.EXPetscSolverConfig sconfig = 3;
inline bool E4mmModel::has_sconfig() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E4mmModel::set_has_sconfig() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E4mmModel::clear_has_sconfig() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E4mmModel::clear_sconfig() {
  if (sconfig_ != NULL) sconfig_->::pb::EXPetscSolverConfig::Clear();
  clear_has_sconfig();
}
inline const ::pb::EXPetscSolverConfig& E4mmModel::sconfig() const {
  // @@protoc_insertion_point(field_get:pb.E4mmModel.sconfig)
  return sconfig_ != NULL ? *sconfig_ : *default_instance_->sconfig_;
}
inline ::pb::EXPetscSolverConfig* E4mmModel::mutable_sconfig() {
  set_has_sconfig();
  if (sconfig_ == NULL) sconfig_ = new ::pb::EXPetscSolverConfig;
  // @@protoc_insertion_point(field_mutable:pb.E4mmModel.sconfig)
  return sconfig_;
}
inline ::pb::EXPetscSolverConfig* E4mmModel::release_sconfig() {
  clear_has_sconfig();
  ::pb::EXPetscSolverConfig* temp = sconfig_;
  sconfig_ = NULL;
  return temp;
}
inline void E4mmModel::set_allocated_sconfig(::pb::EXPetscSolverConfig* sconfig) {
  delete sconfig_;
  sconfig_ = sconfig;
  if (sconfig) {
    set_has_sconfig();
  } else {
    clear_has_sconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E4mmModel.sconfig)
}

// -------------------------------------------------------------------

// E4mmSolution

// required .pb.E4mmState state = 1;
inline bool E4mmSolution::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E4mmSolution::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E4mmSolution::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E4mmSolution::clear_state() {
  if (state_ != NULL) state_->::pb::E4mmState::Clear();
  clear_has_state();
}
inline const ::pb::E4mmState& E4mmSolution::state() const {
  // @@protoc_insertion_point(field_get:pb.E4mmSolution.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::pb::E4mmState* E4mmSolution::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::pb::E4mmState;
  // @@protoc_insertion_point(field_mutable:pb.E4mmSolution.state)
  return state_;
}
inline ::pb::E4mmState* E4mmSolution::release_state() {
  clear_has_state();
  ::pb::E4mmState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void E4mmSolution::set_allocated_state(::pb::E4mmState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E4mmSolution.state)
}

// optional .pb.E4mmState d_state = 2;
inline bool E4mmSolution::has_d_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E4mmSolution::set_has_d_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E4mmSolution::clear_has_d_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E4mmSolution::clear_d_state() {
  if (d_state_ != NULL) d_state_->::pb::E4mmState::Clear();
  clear_has_d_state();
}
inline const ::pb::E4mmState& E4mmSolution::d_state() const {
  // @@protoc_insertion_point(field_get:pb.E4mmSolution.d_state)
  return d_state_ != NULL ? *d_state_ : *default_instance_->d_state_;
}
inline ::pb::E4mmState* E4mmSolution::mutable_d_state() {
  set_has_d_state();
  if (d_state_ == NULL) d_state_ = new ::pb::E4mmState;
  // @@protoc_insertion_point(field_mutable:pb.E4mmSolution.d_state)
  return d_state_;
}
inline ::pb::E4mmState* E4mmSolution::release_d_state() {
  clear_has_d_state();
  ::pb::E4mmState* temp = d_state_;
  d_state_ = NULL;
  return temp;
}
inline void E4mmSolution::set_allocated_d_state(::pb::E4mmState* d_state) {
  delete d_state_;
  d_state_ = d_state;
  if (d_state) {
    set_has_d_state();
  } else {
    clear_has_d_state();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E4mmSolution.d_state)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_model_5fe4mm_2eproto__INCLUDED
