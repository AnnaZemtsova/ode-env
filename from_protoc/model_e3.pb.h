// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model_e3.proto

#ifndef PROTOBUF_model_5fe3_2eproto__INCLUDED
#define PROTOBUF_model_5fe3_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_model_5fe3_2eproto();
void protobuf_AssignDesc_model_5fe3_2eproto();
void protobuf_ShutdownFile_model_5fe3_2eproto();

class E3Config;
class E3State;
class E3State_Particles;
class E3PetscSolverConfig;
class E3Model;
class E3Solution;
class E3Special;

enum E3PetscSolverConfig_Solver {
  E3PetscSolverConfig_Solver_rhs = 0,
  E3PetscSolverConfig_Solver_ifunction_only = 1,
  E3PetscSolverConfig_Solver_ijacobian = 2
};
bool E3PetscSolverConfig_Solver_IsValid(int value);
const E3PetscSolverConfig_Solver E3PetscSolverConfig_Solver_Solver_MIN = E3PetscSolverConfig_Solver_rhs;
const E3PetscSolverConfig_Solver E3PetscSolverConfig_Solver_Solver_MAX = E3PetscSolverConfig_Solver_ijacobian;
const int E3PetscSolverConfig_Solver_Solver_ARRAYSIZE = E3PetscSolverConfig_Solver_Solver_MAX + 1;

const ::google::protobuf::EnumDescriptor* E3PetscSolverConfig_Solver_descriptor();
inline const ::std::string& E3PetscSolverConfig_Solver_Name(E3PetscSolverConfig_Solver value) {
  return ::google::protobuf::internal::NameOfEnum(
    E3PetscSolverConfig_Solver_descriptor(), value);
}
inline bool E3PetscSolverConfig_Solver_Parse(
    const ::std::string& name, E3PetscSolverConfig_Solver* value) {
  return ::google::protobuf::internal::ParseNamedEnum<E3PetscSolverConfig_Solver>(
    E3PetscSolverConfig_Solver_descriptor(), name, value);
}
// ===================================================================

class E3Config : public ::google::protobuf::Message {
 public:
  E3Config();
  virtual ~E3Config();

  E3Config(const E3Config& from);

  inline E3Config& operator=(const E3Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3Config& default_instance();

  void Swap(E3Config* other);

  // implements Message ----------------------------------------------

  E3Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3Config& from);
  void MergeFrom(const E3Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 m = 1;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 1;
  inline ::google::protobuf::uint32 m() const;
  inline void set_m(::google::protobuf::uint32 value);

  // optional double n = 2;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 2;
  inline double n() const;
  inline void set_n(double value);

  // optional double theta_e = 3;
  inline bool has_theta_e() const;
  inline void clear_theta_e();
  static const int kThetaEFieldNumber = 3;
  inline double theta_e() const;
  inline void set_theta_e(double value);

  // optional double gamma_0_2 = 4;
  inline bool has_gamma_0_2() const;
  inline void clear_gamma_0_2();
  static const int kGamma02FieldNumber = 4;
  inline double gamma_0_2() const;
  inline void set_gamma_0_2(double value);

  // optional double delta_e = 5;
  inline bool has_delta_e() const;
  inline void clear_delta_e();
  static const int kDeltaEFieldNumber = 5;
  inline double delta_e() const;
  inline void set_delta_e(double value);

  // optional double r_e = 6;
  inline bool has_r_e() const;
  inline void clear_r_e();
  static const int kREFieldNumber = 6;
  inline double r_e() const;
  inline void set_r_e(double value);

  // @@protoc_insertion_point(class_scope:pb.E3Config)
 private:
  inline void set_has_m();
  inline void clear_has_m();
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_theta_e();
  inline void clear_has_theta_e();
  inline void set_has_gamma_0_2();
  inline void clear_has_gamma_0_2();
  inline void set_has_delta_e();
  inline void clear_has_delta_e();
  inline void set_has_r_e();
  inline void clear_has_r_e();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double n_;
  double theta_e_;
  double gamma_0_2_;
  double delta_e_;
  double r_e_;
  ::google::protobuf::uint32 m_;
  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3Config* default_instance_;
};
// -------------------------------------------------------------------

class E3State_Particles : public ::google::protobuf::Message {
 public:
  E3State_Particles();
  virtual ~E3State_Particles();

  E3State_Particles(const E3State_Particles& from);

  inline E3State_Particles& operator=(const E3State_Particles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3State_Particles& default_instance();

  void Swap(E3State_Particles* other);

  // implements Message ----------------------------------------------

  E3State_Particles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3State_Particles& from);
  void MergeFrom(const E3State_Particles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double a = 3;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 3;
  inline double a() const;
  inline void set_a(double value);

  // required double ksi = 4;
  inline bool has_ksi() const;
  inline void clear_ksi();
  static const int kKsiFieldNumber = 4;
  inline double ksi() const;
  inline void set_ksi(double value);

  // required double eta = 5;
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 5;
  inline double eta() const;
  inline void set_eta(double value);

  // @@protoc_insertion_point(class_scope:pb.E3State.Particles)
 private:
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_ksi();
  inline void clear_has_ksi();
  inline void set_has_eta();
  inline void clear_has_eta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double a_;
  double ksi_;
  double eta_;
  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3State_Particles* default_instance_;
};
// -------------------------------------------------------------------

class E3State : public ::google::protobuf::Message {
 public:
  E3State();
  virtual ~E3State();

  E3State(const E3State& from);

  inline E3State& operator=(const E3State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3State& default_instance();

  void Swap(E3State* other);

  // implements Message ----------------------------------------------

  E3State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3State& from);
  void MergeFrom(const E3State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef E3State_Particles Particles;

  // accessors -------------------------------------------------------

  // optional bool simulated = 1;
  inline bool has_simulated() const;
  inline void clear_simulated();
  static const int kSimulatedFieldNumber = 1;
  inline bool simulated() const;
  inline void set_simulated(bool value);

  // required double E = 3;
  inline bool has_e() const;
  inline void clear_e();
  static const int kEFieldNumber = 3;
  inline double e() const;
  inline void set_e(double value);

  // required double phi = 4;
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 4;
  inline double phi() const;
  inline void set_phi(double value);

  // optional double a0 = 5;
  inline bool has_a0() const;
  inline void clear_a0();
  static const int kA0FieldNumber = 5;
  inline double a0() const;
  inline void set_a0(double value);

  // repeated group Particles = 2 {
  inline int particles_size() const;
  inline void clear_particles();
  static const int kParticlesFieldNumber = 2;
  inline const ::pb::E3State_Particles& particles(int index) const;
  inline ::pb::E3State_Particles* mutable_particles(int index);
  inline ::pb::E3State_Particles* add_particles();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles >&
      particles() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles >*
      mutable_particles();

  // @@protoc_insertion_point(class_scope:pb.E3State)
 private:
  inline void set_has_simulated();
  inline void clear_has_simulated();
  inline void set_has_e();
  inline void clear_has_e();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_a0();
  inline void clear_has_a0();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double e_;
  double phi_;
  double a0_;
  ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles > particles_;
  bool simulated_;
  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3State* default_instance_;
};
// -------------------------------------------------------------------

class E3PetscSolverConfig : public ::google::protobuf::Message {
 public:
  E3PetscSolverConfig();
  virtual ~E3PetscSolverConfig();

  E3PetscSolverConfig(const E3PetscSolverConfig& from);

  inline E3PetscSolverConfig& operator=(const E3PetscSolverConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3PetscSolverConfig& default_instance();

  void Swap(E3PetscSolverConfig* other);

  // implements Message ----------------------------------------------

  E3PetscSolverConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3PetscSolverConfig& from);
  void MergeFrom(const E3PetscSolverConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef E3PetscSolverConfig_Solver Solver;
  static const Solver rhs = E3PetscSolverConfig_Solver_rhs;
  static const Solver ifunction_only = E3PetscSolverConfig_Solver_ifunction_only;
  static const Solver ijacobian = E3PetscSolverConfig_Solver_ijacobian;
  static inline bool Solver_IsValid(int value) {
    return E3PetscSolverConfig_Solver_IsValid(value);
  }
  static const Solver Solver_MIN =
    E3PetscSolverConfig_Solver_Solver_MIN;
  static const Solver Solver_MAX =
    E3PetscSolverConfig_Solver_Solver_MAX;
  static const int Solver_ARRAYSIZE =
    E3PetscSolverConfig_Solver_Solver_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Solver_descriptor() {
    return E3PetscSolverConfig_Solver_descriptor();
  }
  static inline const ::std::string& Solver_Name(Solver value) {
    return E3PetscSolverConfig_Solver_Name(value);
  }
  static inline bool Solver_Parse(const ::std::string& name,
      Solver* value) {
    return E3PetscSolverConfig_Solver_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double atol = 1;
  inline bool has_atol() const;
  inline void clear_atol();
  static const int kAtolFieldNumber = 1;
  inline double atol() const;
  inline void set_atol(double value);

  // optional double rtol = 4;
  inline bool has_rtol() const;
  inline void clear_rtol();
  static const int kRtolFieldNumber = 4;
  inline double rtol() const;
  inline void set_rtol(double value);

  // optional double init_step = 2;
  inline bool has_init_step() const;
  inline void clear_init_step();
  static const int kInitStepFieldNumber = 2;
  inline double init_step() const;
  inline void set_init_step(double value);

  // required string model = 3;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 3;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional .pb.E3PetscSolverConfig.Solver solver = 5;
  inline bool has_solver() const;
  inline void clear_solver();
  static const int kSolverFieldNumber = 5;
  inline ::pb::E3PetscSolverConfig_Solver solver() const;
  inline void set_solver(::pb::E3PetscSolverConfig_Solver value);

  // optional int32 n_cores = 6;
  inline bool has_n_cores() const;
  inline void clear_n_cores();
  static const int kNCoresFieldNumber = 6;
  inline ::google::protobuf::int32 n_cores() const;
  inline void set_n_cores(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.E3PetscSolverConfig)
 private:
  inline void set_has_atol();
  inline void clear_has_atol();
  inline void set_has_rtol();
  inline void clear_has_rtol();
  inline void set_has_init_step();
  inline void clear_has_init_step();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_solver();
  inline void clear_has_solver();
  inline void set_has_n_cores();
  inline void clear_has_n_cores();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double atol_;
  double rtol_;
  double init_step_;
  ::std::string* model_;
  int solver_;
  ::google::protobuf::int32 n_cores_;
  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3PetscSolverConfig* default_instance_;
};
// -------------------------------------------------------------------

class E3Model : public ::google::protobuf::Message {
 public:
  E3Model();
  virtual ~E3Model();

  E3Model(const E3Model& from);

  inline E3Model& operator=(const E3Model& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3Model& default_instance();

  void Swap(E3Model* other);

  // implements Message ----------------------------------------------

  E3Model* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3Model& from);
  void MergeFrom(const E3Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.E3Config pconfig = 1;
  inline bool has_pconfig() const;
  inline void clear_pconfig();
  static const int kPconfigFieldNumber = 1;
  inline const ::pb::E3Config& pconfig() const;
  inline ::pb::E3Config* mutable_pconfig();
  inline ::pb::E3Config* release_pconfig();
  inline void set_allocated_pconfig(::pb::E3Config* pconfig);

  // required .pb.E3State state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::pb::E3State& state() const;
  inline ::pb::E3State* mutable_state();
  inline ::pb::E3State* release_state();
  inline void set_allocated_state(::pb::E3State* state);

  // required .pb.E3PetscSolverConfig sconfig = 3;
  inline bool has_sconfig() const;
  inline void clear_sconfig();
  static const int kSconfigFieldNumber = 3;
  inline const ::pb::E3PetscSolverConfig& sconfig() const;
  inline ::pb::E3PetscSolverConfig* mutable_sconfig();
  inline ::pb::E3PetscSolverConfig* release_sconfig();
  inline void set_allocated_sconfig(::pb::E3PetscSolverConfig* sconfig);

  // @@protoc_insertion_point(class_scope:pb.E3Model)
 private:
  inline void set_has_pconfig();
  inline void clear_has_pconfig();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sconfig();
  inline void clear_has_sconfig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::E3Config* pconfig_;
  ::pb::E3State* state_;
  ::pb::E3PetscSolverConfig* sconfig_;
  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3Model* default_instance_;
};
// -------------------------------------------------------------------

class E3Solution : public ::google::protobuf::Message {
 public:
  E3Solution();
  virtual ~E3Solution();

  E3Solution(const E3Solution& from);

  inline E3Solution& operator=(const E3Solution& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3Solution& default_instance();

  void Swap(E3Solution* other);

  // implements Message ----------------------------------------------

  E3Solution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3Solution& from);
  void MergeFrom(const E3Solution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.E3State state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::pb::E3State& state() const;
  inline ::pb::E3State* mutable_state();
  inline ::pb::E3State* release_state();
  inline void set_allocated_state(::pb::E3State* state);

  // optional .pb.E3State d_state = 2;
  inline bool has_d_state() const;
  inline void clear_d_state();
  static const int kDStateFieldNumber = 2;
  inline const ::pb::E3State& d_state() const;
  inline ::pb::E3State* mutable_d_state();
  inline ::pb::E3State* release_d_state();
  inline void set_allocated_d_state(::pb::E3State* d_state);

  // @@protoc_insertion_point(class_scope:pb.E3Solution)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_d_state();
  inline void clear_has_d_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::E3State* state_;
  ::pb::E3State* d_state_;
  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3Solution* default_instance_;
};
// -------------------------------------------------------------------

class E3Special : public ::google::protobuf::Message {
 public:
  E3Special();
  virtual ~E3Special();

  E3Special(const E3Special& from);

  inline E3Special& operator=(const E3Special& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3Special& default_instance();

  void Swap(E3Special* other);

  // implements Message ----------------------------------------------

  E3Special* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3Special& from);
  void MergeFrom(const E3Special& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double e_2 = 1;
  inline bool has_e_2() const;
  inline void clear_e_2();
  static const int kE2FieldNumber = 1;
  inline double e_2() const;
  inline void set_e_2(double value);

  // optional double aver_a_2 = 2;
  inline bool has_aver_a_2() const;
  inline void clear_aver_a_2();
  static const int kAverA2FieldNumber = 2;
  inline double aver_a_2() const;
  inline void set_aver_a_2(double value);

  // optional double aver_eta = 3;
  inline bool has_aver_eta() const;
  inline void clear_aver_eta();
  static const int kAverEtaFieldNumber = 3;
  inline double aver_eta() const;
  inline void set_aver_eta(double value);

  // optional double int_e_a = 4;
  inline bool has_int_e_a() const;
  inline void clear_int_e_a();
  static const int kIntEAFieldNumber = 4;
  inline double int_e_a() const;
  inline void set_int_e_a(double value);

  // @@protoc_insertion_point(class_scope:pb.E3Special)
 private:
  inline void set_has_e_2();
  inline void clear_has_e_2();
  inline void set_has_aver_a_2();
  inline void clear_has_aver_a_2();
  inline void set_has_aver_eta();
  inline void clear_has_aver_eta();
  inline void set_has_int_e_a();
  inline void clear_has_int_e_a();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double e_2_;
  double aver_a_2_;
  double aver_eta_;
  double int_e_a_;
  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3Special* default_instance_;
};
// ===================================================================


// ===================================================================

// E3Config

// required uint32 m = 1;
inline bool E3Config::has_m() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3Config::set_has_m() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3Config::clear_has_m() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3Config::clear_m() {
  m_ = 0u;
  clear_has_m();
}
inline ::google::protobuf::uint32 E3Config::m() const {
  // @@protoc_insertion_point(field_get:pb.E3Config.m)
  return m_;
}
inline void E3Config::set_m(::google::protobuf::uint32 value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Config.m)
}

// optional double n = 2;
inline bool E3Config::has_n() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3Config::set_has_n() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3Config::clear_has_n() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3Config::clear_n() {
  n_ = 0;
  clear_has_n();
}
inline double E3Config::n() const {
  // @@protoc_insertion_point(field_get:pb.E3Config.n)
  return n_;
}
inline void E3Config::set_n(double value) {
  set_has_n();
  n_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Config.n)
}

// optional double theta_e = 3;
inline bool E3Config::has_theta_e() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3Config::set_has_theta_e() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3Config::clear_has_theta_e() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3Config::clear_theta_e() {
  theta_e_ = 0;
  clear_has_theta_e();
}
inline double E3Config::theta_e() const {
  // @@protoc_insertion_point(field_get:pb.E3Config.theta_e)
  return theta_e_;
}
inline void E3Config::set_theta_e(double value) {
  set_has_theta_e();
  theta_e_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Config.theta_e)
}

// optional double gamma_0_2 = 4;
inline bool E3Config::has_gamma_0_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void E3Config::set_has_gamma_0_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void E3Config::clear_has_gamma_0_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void E3Config::clear_gamma_0_2() {
  gamma_0_2_ = 0;
  clear_has_gamma_0_2();
}
inline double E3Config::gamma_0_2() const {
  // @@protoc_insertion_point(field_get:pb.E3Config.gamma_0_2)
  return gamma_0_2_;
}
inline void E3Config::set_gamma_0_2(double value) {
  set_has_gamma_0_2();
  gamma_0_2_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Config.gamma_0_2)
}

// optional double delta_e = 5;
inline bool E3Config::has_delta_e() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void E3Config::set_has_delta_e() {
  _has_bits_[0] |= 0x00000010u;
}
inline void E3Config::clear_has_delta_e() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void E3Config::clear_delta_e() {
  delta_e_ = 0;
  clear_has_delta_e();
}
inline double E3Config::delta_e() const {
  // @@protoc_insertion_point(field_get:pb.E3Config.delta_e)
  return delta_e_;
}
inline void E3Config::set_delta_e(double value) {
  set_has_delta_e();
  delta_e_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Config.delta_e)
}

// optional double r_e = 6;
inline bool E3Config::has_r_e() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void E3Config::set_has_r_e() {
  _has_bits_[0] |= 0x00000020u;
}
inline void E3Config::clear_has_r_e() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void E3Config::clear_r_e() {
  r_e_ = 0;
  clear_has_r_e();
}
inline double E3Config::r_e() const {
  // @@protoc_insertion_point(field_get:pb.E3Config.r_e)
  return r_e_;
}
inline void E3Config::set_r_e(double value) {
  set_has_r_e();
  r_e_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Config.r_e)
}

// -------------------------------------------------------------------

// E3State_Particles

// required double a = 3;
inline bool E3State_Particles::has_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3State_Particles::set_has_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3State_Particles::clear_has_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3State_Particles::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline double E3State_Particles::a() const {
  // @@protoc_insertion_point(field_get:pb.E3State.Particles.a)
  return a_;
}
inline void E3State_Particles::set_a(double value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:pb.E3State.Particles.a)
}

// required double ksi = 4;
inline bool E3State_Particles::has_ksi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3State_Particles::set_has_ksi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3State_Particles::clear_has_ksi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3State_Particles::clear_ksi() {
  ksi_ = 0;
  clear_has_ksi();
}
inline double E3State_Particles::ksi() const {
  // @@protoc_insertion_point(field_get:pb.E3State.Particles.ksi)
  return ksi_;
}
inline void E3State_Particles::set_ksi(double value) {
  set_has_ksi();
  ksi_ = value;
  // @@protoc_insertion_point(field_set:pb.E3State.Particles.ksi)
}

// required double eta = 5;
inline bool E3State_Particles::has_eta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3State_Particles::set_has_eta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3State_Particles::clear_has_eta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3State_Particles::clear_eta() {
  eta_ = 0;
  clear_has_eta();
}
inline double E3State_Particles::eta() const {
  // @@protoc_insertion_point(field_get:pb.E3State.Particles.eta)
  return eta_;
}
inline void E3State_Particles::set_eta(double value) {
  set_has_eta();
  eta_ = value;
  // @@protoc_insertion_point(field_set:pb.E3State.Particles.eta)
}

// -------------------------------------------------------------------

// E3State

// optional bool simulated = 1;
inline bool E3State::has_simulated() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3State::set_has_simulated() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3State::clear_has_simulated() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3State::clear_simulated() {
  simulated_ = false;
  clear_has_simulated();
}
inline bool E3State::simulated() const {
  // @@protoc_insertion_point(field_get:pb.E3State.simulated)
  return simulated_;
}
inline void E3State::set_simulated(bool value) {
  set_has_simulated();
  simulated_ = value;
  // @@protoc_insertion_point(field_set:pb.E3State.simulated)
}

// required double E = 3;
inline bool E3State::has_e() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3State::set_has_e() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3State::clear_has_e() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3State::clear_e() {
  e_ = 0;
  clear_has_e();
}
inline double E3State::e() const {
  // @@protoc_insertion_point(field_get:pb.E3State.E)
  return e_;
}
inline void E3State::set_e(double value) {
  set_has_e();
  e_ = value;
  // @@protoc_insertion_point(field_set:pb.E3State.E)
}

// required double phi = 4;
inline bool E3State::has_phi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3State::set_has_phi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3State::clear_has_phi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3State::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double E3State::phi() const {
  // @@protoc_insertion_point(field_get:pb.E3State.phi)
  return phi_;
}
inline void E3State::set_phi(double value) {
  set_has_phi();
  phi_ = value;
  // @@protoc_insertion_point(field_set:pb.E3State.phi)
}

// optional double a0 = 5;
inline bool E3State::has_a0() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void E3State::set_has_a0() {
  _has_bits_[0] |= 0x00000008u;
}
inline void E3State::clear_has_a0() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void E3State::clear_a0() {
  a0_ = 0;
  clear_has_a0();
}
inline double E3State::a0() const {
  // @@protoc_insertion_point(field_get:pb.E3State.a0)
  return a0_;
}
inline void E3State::set_a0(double value) {
  set_has_a0();
  a0_ = value;
  // @@protoc_insertion_point(field_set:pb.E3State.a0)
}

// repeated group Particles = 2 {
inline int E3State::particles_size() const {
  return particles_.size();
}
inline void E3State::clear_particles() {
  particles_.Clear();
}
inline const ::pb::E3State_Particles& E3State::particles(int index) const {
  // @@protoc_insertion_point(field_get:pb.E3State.particles)
  return particles_.Get(index);
}
inline ::pb::E3State_Particles* E3State::mutable_particles(int index) {
  // @@protoc_insertion_point(field_mutable:pb.E3State.particles)
  return particles_.Mutable(index);
}
inline ::pb::E3State_Particles* E3State::add_particles() {
  // @@protoc_insertion_point(field_add:pb.E3State.particles)
  return particles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles >&
E3State::particles() const {
  // @@protoc_insertion_point(field_list:pb.E3State.particles)
  return particles_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles >*
E3State::mutable_particles() {
  // @@protoc_insertion_point(field_mutable_list:pb.E3State.particles)
  return &particles_;
}

// -------------------------------------------------------------------

// E3PetscSolverConfig

// optional double atol = 1;
inline bool E3PetscSolverConfig::has_atol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3PetscSolverConfig::set_has_atol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3PetscSolverConfig::clear_has_atol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3PetscSolverConfig::clear_atol() {
  atol_ = 0;
  clear_has_atol();
}
inline double E3PetscSolverConfig::atol() const {
  // @@protoc_insertion_point(field_get:pb.E3PetscSolverConfig.atol)
  return atol_;
}
inline void E3PetscSolverConfig::set_atol(double value) {
  set_has_atol();
  atol_ = value;
  // @@protoc_insertion_point(field_set:pb.E3PetscSolverConfig.atol)
}

// optional double rtol = 4;
inline bool E3PetscSolverConfig::has_rtol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3PetscSolverConfig::set_has_rtol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3PetscSolverConfig::clear_has_rtol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3PetscSolverConfig::clear_rtol() {
  rtol_ = 0;
  clear_has_rtol();
}
inline double E3PetscSolverConfig::rtol() const {
  // @@protoc_insertion_point(field_get:pb.E3PetscSolverConfig.rtol)
  return rtol_;
}
inline void E3PetscSolverConfig::set_rtol(double value) {
  set_has_rtol();
  rtol_ = value;
  // @@protoc_insertion_point(field_set:pb.E3PetscSolverConfig.rtol)
}

// optional double init_step = 2;
inline bool E3PetscSolverConfig::has_init_step() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3PetscSolverConfig::set_has_init_step() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3PetscSolverConfig::clear_has_init_step() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3PetscSolverConfig::clear_init_step() {
  init_step_ = 0;
  clear_has_init_step();
}
inline double E3PetscSolverConfig::init_step() const {
  // @@protoc_insertion_point(field_get:pb.E3PetscSolverConfig.init_step)
  return init_step_;
}
inline void E3PetscSolverConfig::set_init_step(double value) {
  set_has_init_step();
  init_step_ = value;
  // @@protoc_insertion_point(field_set:pb.E3PetscSolverConfig.init_step)
}

// required string model = 3;
inline bool E3PetscSolverConfig::has_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void E3PetscSolverConfig::set_has_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void E3PetscSolverConfig::clear_has_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void E3PetscSolverConfig::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& E3PetscSolverConfig::model() const {
  // @@protoc_insertion_point(field_get:pb.E3PetscSolverConfig.model)
  return *model_;
}
inline void E3PetscSolverConfig::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:pb.E3PetscSolverConfig.model)
}
inline void E3PetscSolverConfig::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.E3PetscSolverConfig.model)
}
inline void E3PetscSolverConfig::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.E3PetscSolverConfig.model)
}
inline ::std::string* E3PetscSolverConfig::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.E3PetscSolverConfig.model)
  return model_;
}
inline ::std::string* E3PetscSolverConfig::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void E3PetscSolverConfig::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E3PetscSolverConfig.model)
}

// optional .pb.E3PetscSolverConfig.Solver solver = 5;
inline bool E3PetscSolverConfig::has_solver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void E3PetscSolverConfig::set_has_solver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void E3PetscSolverConfig::clear_has_solver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void E3PetscSolverConfig::clear_solver() {
  solver_ = 0;
  clear_has_solver();
}
inline ::pb::E3PetscSolverConfig_Solver E3PetscSolverConfig::solver() const {
  // @@protoc_insertion_point(field_get:pb.E3PetscSolverConfig.solver)
  return static_cast< ::pb::E3PetscSolverConfig_Solver >(solver_);
}
inline void E3PetscSolverConfig::set_solver(::pb::E3PetscSolverConfig_Solver value) {
  assert(::pb::E3PetscSolverConfig_Solver_IsValid(value));
  set_has_solver();
  solver_ = value;
  // @@protoc_insertion_point(field_set:pb.E3PetscSolverConfig.solver)
}

// optional int32 n_cores = 6;
inline bool E3PetscSolverConfig::has_n_cores() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void E3PetscSolverConfig::set_has_n_cores() {
  _has_bits_[0] |= 0x00000020u;
}
inline void E3PetscSolverConfig::clear_has_n_cores() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void E3PetscSolverConfig::clear_n_cores() {
  n_cores_ = 0;
  clear_has_n_cores();
}
inline ::google::protobuf::int32 E3PetscSolverConfig::n_cores() const {
  // @@protoc_insertion_point(field_get:pb.E3PetscSolverConfig.n_cores)
  return n_cores_;
}
inline void E3PetscSolverConfig::set_n_cores(::google::protobuf::int32 value) {
  set_has_n_cores();
  n_cores_ = value;
  // @@protoc_insertion_point(field_set:pb.E3PetscSolverConfig.n_cores)
}

// -------------------------------------------------------------------

// E3Model

// required .pb.E3Config pconfig = 1;
inline bool E3Model::has_pconfig() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3Model::set_has_pconfig() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3Model::clear_has_pconfig() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3Model::clear_pconfig() {
  if (pconfig_ != NULL) pconfig_->::pb::E3Config::Clear();
  clear_has_pconfig();
}
inline const ::pb::E3Config& E3Model::pconfig() const {
  // @@protoc_insertion_point(field_get:pb.E3Model.pconfig)
  return pconfig_ != NULL ? *pconfig_ : *default_instance_->pconfig_;
}
inline ::pb::E3Config* E3Model::mutable_pconfig() {
  set_has_pconfig();
  if (pconfig_ == NULL) pconfig_ = new ::pb::E3Config;
  // @@protoc_insertion_point(field_mutable:pb.E3Model.pconfig)
  return pconfig_;
}
inline ::pb::E3Config* E3Model::release_pconfig() {
  clear_has_pconfig();
  ::pb::E3Config* temp = pconfig_;
  pconfig_ = NULL;
  return temp;
}
inline void E3Model::set_allocated_pconfig(::pb::E3Config* pconfig) {
  delete pconfig_;
  pconfig_ = pconfig;
  if (pconfig) {
    set_has_pconfig();
  } else {
    clear_has_pconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E3Model.pconfig)
}

// required .pb.E3State state = 2;
inline bool E3Model::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3Model::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3Model::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3Model::clear_state() {
  if (state_ != NULL) state_->::pb::E3State::Clear();
  clear_has_state();
}
inline const ::pb::E3State& E3Model::state() const {
  // @@protoc_insertion_point(field_get:pb.E3Model.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::pb::E3State* E3Model::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::pb::E3State;
  // @@protoc_insertion_point(field_mutable:pb.E3Model.state)
  return state_;
}
inline ::pb::E3State* E3Model::release_state() {
  clear_has_state();
  ::pb::E3State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void E3Model::set_allocated_state(::pb::E3State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E3Model.state)
}

// required .pb.E3PetscSolverConfig sconfig = 3;
inline bool E3Model::has_sconfig() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3Model::set_has_sconfig() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3Model::clear_has_sconfig() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3Model::clear_sconfig() {
  if (sconfig_ != NULL) sconfig_->::pb::E3PetscSolverConfig::Clear();
  clear_has_sconfig();
}
inline const ::pb::E3PetscSolverConfig& E3Model::sconfig() const {
  // @@protoc_insertion_point(field_get:pb.E3Model.sconfig)
  return sconfig_ != NULL ? *sconfig_ : *default_instance_->sconfig_;
}
inline ::pb::E3PetscSolverConfig* E3Model::mutable_sconfig() {
  set_has_sconfig();
  if (sconfig_ == NULL) sconfig_ = new ::pb::E3PetscSolverConfig;
  // @@protoc_insertion_point(field_mutable:pb.E3Model.sconfig)
  return sconfig_;
}
inline ::pb::E3PetscSolverConfig* E3Model::release_sconfig() {
  clear_has_sconfig();
  ::pb::E3PetscSolverConfig* temp = sconfig_;
  sconfig_ = NULL;
  return temp;
}
inline void E3Model::set_allocated_sconfig(::pb::E3PetscSolverConfig* sconfig) {
  delete sconfig_;
  sconfig_ = sconfig;
  if (sconfig) {
    set_has_sconfig();
  } else {
    clear_has_sconfig();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E3Model.sconfig)
}

// -------------------------------------------------------------------

// E3Solution

// required .pb.E3State state = 1;
inline bool E3Solution::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3Solution::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3Solution::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3Solution::clear_state() {
  if (state_ != NULL) state_->::pb::E3State::Clear();
  clear_has_state();
}
inline const ::pb::E3State& E3Solution::state() const {
  // @@protoc_insertion_point(field_get:pb.E3Solution.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::pb::E3State* E3Solution::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::pb::E3State;
  // @@protoc_insertion_point(field_mutable:pb.E3Solution.state)
  return state_;
}
inline ::pb::E3State* E3Solution::release_state() {
  clear_has_state();
  ::pb::E3State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void E3Solution::set_allocated_state(::pb::E3State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E3Solution.state)
}

// optional .pb.E3State d_state = 2;
inline bool E3Solution::has_d_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3Solution::set_has_d_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3Solution::clear_has_d_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3Solution::clear_d_state() {
  if (d_state_ != NULL) d_state_->::pb::E3State::Clear();
  clear_has_d_state();
}
inline const ::pb::E3State& E3Solution::d_state() const {
  // @@protoc_insertion_point(field_get:pb.E3Solution.d_state)
  return d_state_ != NULL ? *d_state_ : *default_instance_->d_state_;
}
inline ::pb::E3State* E3Solution::mutable_d_state() {
  set_has_d_state();
  if (d_state_ == NULL) d_state_ = new ::pb::E3State;
  // @@protoc_insertion_point(field_mutable:pb.E3Solution.d_state)
  return d_state_;
}
inline ::pb::E3State* E3Solution::release_d_state() {
  clear_has_d_state();
  ::pb::E3State* temp = d_state_;
  d_state_ = NULL;
  return temp;
}
inline void E3Solution::set_allocated_d_state(::pb::E3State* d_state) {
  delete d_state_;
  d_state_ = d_state;
  if (d_state) {
    set_has_d_state();
  } else {
    clear_has_d_state();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.E3Solution.d_state)
}

// -------------------------------------------------------------------

// E3Special

// optional double e_2 = 1;
inline bool E3Special::has_e_2() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3Special::set_has_e_2() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3Special::clear_has_e_2() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3Special::clear_e_2() {
  e_2_ = 0;
  clear_has_e_2();
}
inline double E3Special::e_2() const {
  // @@protoc_insertion_point(field_get:pb.E3Special.e_2)
  return e_2_;
}
inline void E3Special::set_e_2(double value) {
  set_has_e_2();
  e_2_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Special.e_2)
}

// optional double aver_a_2 = 2;
inline bool E3Special::has_aver_a_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3Special::set_has_aver_a_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3Special::clear_has_aver_a_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3Special::clear_aver_a_2() {
  aver_a_2_ = 0;
  clear_has_aver_a_2();
}
inline double E3Special::aver_a_2() const {
  // @@protoc_insertion_point(field_get:pb.E3Special.aver_a_2)
  return aver_a_2_;
}
inline void E3Special::set_aver_a_2(double value) {
  set_has_aver_a_2();
  aver_a_2_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Special.aver_a_2)
}

// optional double aver_eta = 3;
inline bool E3Special::has_aver_eta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3Special::set_has_aver_eta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3Special::clear_has_aver_eta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3Special::clear_aver_eta() {
  aver_eta_ = 0;
  clear_has_aver_eta();
}
inline double E3Special::aver_eta() const {
  // @@protoc_insertion_point(field_get:pb.E3Special.aver_eta)
  return aver_eta_;
}
inline void E3Special::set_aver_eta(double value) {
  set_has_aver_eta();
  aver_eta_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Special.aver_eta)
}

// optional double int_e_a = 4;
inline bool E3Special::has_int_e_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void E3Special::set_has_int_e_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void E3Special::clear_has_int_e_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void E3Special::clear_int_e_a() {
  int_e_a_ = 0;
  clear_has_int_e_a();
}
inline double E3Special::int_e_a() const {
  // @@protoc_insertion_point(field_get:pb.E3Special.int_e_a)
  return int_e_a_;
}
inline void E3Special::set_int_e_a(double value) {
  set_has_int_e_a();
  int_e_a_ = value;
  // @@protoc_insertion_point(field_set:pb.E3Special.int_e_a)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::E3PetscSolverConfig_Solver> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::E3PetscSolverConfig_Solver>() {
  return ::pb::E3PetscSolverConfig_Solver_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_model_5fe3_2eproto__INCLUDED
