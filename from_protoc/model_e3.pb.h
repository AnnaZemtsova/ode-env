// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model_e3.proto

#ifndef PROTOBUF_model_5fe3_2eproto__INCLUDED
#define PROTOBUF_model_5fe3_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_model_5fe3_2eproto();
void protobuf_AssignDesc_model_5fe3_2eproto();
void protobuf_ShutdownFile_model_5fe3_2eproto();

class E3Config;
class E3State;
class E3State_Particles;
class E3PetscSolverConfig;
class E3Model;

// ===================================================================

class E3Config : public ::google::protobuf::Message {
 public:
  E3Config();
  virtual ~E3Config();

  E3Config(const E3Config& from);

  inline E3Config& operator=(const E3Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3Config& default_instance();

  void Swap(E3Config* other);

  // implements Message ----------------------------------------------

  E3Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3Config& from);
  void MergeFrom(const E3Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 m = 1;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 1;
  inline ::google::protobuf::uint32 m() const;
  inline void set_m(::google::protobuf::uint32 value);

  // optional double n = 2;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 2;
  inline double n() const;
  inline void set_n(double value);

  // optional double theta_e = 3;
  inline bool has_theta_e() const;
  inline void clear_theta_e();
  static const int kThetaEFieldNumber = 3;
  inline double theta_e() const;
  inline void set_theta_e(double value);

  // optional double gamma_0_2 = 4;
  inline bool has_gamma_0_2() const;
  inline void clear_gamma_0_2();
  static const int kGamma02FieldNumber = 4;
  inline double gamma_0_2() const;
  inline void set_gamma_0_2(double value);

  // optional double delta_e = 5;
  inline bool has_delta_e() const;
  inline void clear_delta_e();
  static const int kDeltaEFieldNumber = 5;
  inline double delta_e() const;
  inline void set_delta_e(double value);

  // optional double r_e = 6;
  inline bool has_r_e() const;
  inline void clear_r_e();
  static const int kREFieldNumber = 6;
  inline double r_e() const;
  inline void set_r_e(double value);

  // @@protoc_insertion_point(class_scope:pb.E3Config)
 private:
  inline void set_has_m();
  inline void clear_has_m();
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_theta_e();
  inline void clear_has_theta_e();
  inline void set_has_gamma_0_2();
  inline void clear_has_gamma_0_2();
  inline void set_has_delta_e();
  inline void clear_has_delta_e();
  inline void set_has_r_e();
  inline void clear_has_r_e();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double n_;
  double theta_e_;
  double gamma_0_2_;
  double delta_e_;
  double r_e_;
  ::google::protobuf::uint32 m_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3Config* default_instance_;
};
// -------------------------------------------------------------------

class E3State_Particles : public ::google::protobuf::Message {
 public:
  E3State_Particles();
  virtual ~E3State_Particles();

  E3State_Particles(const E3State_Particles& from);

  inline E3State_Particles& operator=(const E3State_Particles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3State_Particles& default_instance();

  void Swap(E3State_Particles* other);

  // implements Message ----------------------------------------------

  E3State_Particles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3State_Particles& from);
  void MergeFrom(const E3State_Particles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double a = 3;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 3;
  inline double a() const;
  inline void set_a(double value);

  // required double ksi = 4;
  inline bool has_ksi() const;
  inline void clear_ksi();
  static const int kKsiFieldNumber = 4;
  inline double ksi() const;
  inline void set_ksi(double value);

  // required double eta = 5;
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 5;
  inline double eta() const;
  inline void set_eta(double value);

  // @@protoc_insertion_point(class_scope:pb.E3State.Particles)
 private:
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_ksi();
  inline void clear_has_ksi();
  inline void set_has_eta();
  inline void clear_has_eta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double a_;
  double ksi_;
  double eta_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3State_Particles* default_instance_;
};
// -------------------------------------------------------------------

class E3State : public ::google::protobuf::Message {
 public:
  E3State();
  virtual ~E3State();

  E3State(const E3State& from);

  inline E3State& operator=(const E3State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3State& default_instance();

  void Swap(E3State* other);

  // implements Message ----------------------------------------------

  E3State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3State& from);
  void MergeFrom(const E3State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef E3State_Particles Particles;

  // accessors -------------------------------------------------------

  // optional bool simulated = 1;
  inline bool has_simulated() const;
  inline void clear_simulated();
  static const int kSimulatedFieldNumber = 1;
  inline bool simulated() const;
  inline void set_simulated(bool value);

  // required double E = 3;
  inline bool has_e() const;
  inline void clear_e();
  static const int kEFieldNumber = 3;
  inline double e() const;
  inline void set_e(double value);

  // required double phi = 4;
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 4;
  inline double phi() const;
  inline void set_phi(double value);

  // repeated group Particles = 2 {
  inline int particles_size() const;
  inline void clear_particles();
  static const int kParticlesFieldNumber = 2;
  inline const ::pb::E3State_Particles& particles(int index) const;
  inline ::pb::E3State_Particles* mutable_particles(int index);
  inline ::pb::E3State_Particles* add_particles();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles >&
      particles() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles >*
      mutable_particles();

  // @@protoc_insertion_point(class_scope:pb.E3State)
 private:
  inline void set_has_simulated();
  inline void clear_has_simulated();
  inline void set_has_e();
  inline void clear_has_e();
  inline void set_has_phi();
  inline void clear_has_phi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double e_;
  double phi_;
  ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles > particles_;
  bool simulated_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3State* default_instance_;
};
// -------------------------------------------------------------------

class E3PetscSolverConfig : public ::google::protobuf::Message {
 public:
  E3PetscSolverConfig();
  virtual ~E3PetscSolverConfig();

  E3PetscSolverConfig(const E3PetscSolverConfig& from);

  inline E3PetscSolverConfig& operator=(const E3PetscSolverConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3PetscSolverConfig& default_instance();

  void Swap(E3PetscSolverConfig* other);

  // implements Message ----------------------------------------------

  E3PetscSolverConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3PetscSolverConfig& from);
  void MergeFrom(const E3PetscSolverConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double tolerance = 1;
  inline bool has_tolerance() const;
  inline void clear_tolerance();
  static const int kToleranceFieldNumber = 1;
  inline double tolerance() const;
  inline void set_tolerance(double value);

  // optional double init_step = 2;
  inline bool has_init_step() const;
  inline void clear_init_step();
  static const int kInitStepFieldNumber = 2;
  inline double init_step() const;
  inline void set_init_step(double value);

  // @@protoc_insertion_point(class_scope:pb.E3PetscSolverConfig)
 private:
  inline void set_has_tolerance();
  inline void clear_has_tolerance();
  inline void set_has_init_step();
  inline void clear_has_init_step();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double tolerance_;
  double init_step_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3PetscSolverConfig* default_instance_;
};
// -------------------------------------------------------------------

class E3Model : public ::google::protobuf::Message {
 public:
  E3Model();
  virtual ~E3Model();

  E3Model(const E3Model& from);

  inline E3Model& operator=(const E3Model& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const E3Model& default_instance();

  void Swap(E3Model* other);

  // implements Message ----------------------------------------------

  E3Model* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const E3Model& from);
  void MergeFrom(const E3Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline double time() const;
  inline void set_time(double value);

  // required uint32 steps = 5;
  inline bool has_steps() const;
  inline void clear_steps();
  static const int kStepsFieldNumber = 5;
  inline ::google::protobuf::uint32 steps() const;
  inline void set_steps(::google::protobuf::uint32 value);

  // required .pb.E3Config pconfig = 1;
  inline bool has_pconfig() const;
  inline void clear_pconfig();
  static const int kPconfigFieldNumber = 1;
  inline const ::pb::E3Config& pconfig() const;
  inline ::pb::E3Config* mutable_pconfig();
  inline ::pb::E3Config* release_pconfig();
  inline void set_allocated_pconfig(::pb::E3Config* pconfig);

  // required .pb.E3State state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::pb::E3State& state() const;
  inline ::pb::E3State* mutable_state();
  inline ::pb::E3State* release_state();
  inline void set_allocated_state(::pb::E3State* state);

  // required .pb.E3PetscSolverConfig sconfig = 3;
  inline bool has_sconfig() const;
  inline void clear_sconfig();
  static const int kSconfigFieldNumber = 3;
  inline const ::pb::E3PetscSolverConfig& sconfig() const;
  inline ::pb::E3PetscSolverConfig* mutable_sconfig();
  inline ::pb::E3PetscSolverConfig* release_sconfig();
  inline void set_allocated_sconfig(::pb::E3PetscSolverConfig* sconfig);

  // @@protoc_insertion_point(class_scope:pb.E3Model)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_steps();
  inline void clear_has_steps();
  inline void set_has_pconfig();
  inline void clear_has_pconfig();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sconfig();
  inline void clear_has_sconfig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  ::pb::E3Config* pconfig_;
  ::pb::E3State* state_;
  ::pb::E3PetscSolverConfig* sconfig_;
  ::google::protobuf::uint32 steps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_model_5fe3_2eproto();
  friend void protobuf_AssignDesc_model_5fe3_2eproto();
  friend void protobuf_ShutdownFile_model_5fe3_2eproto();

  void InitAsDefaultInstance();
  static E3Model* default_instance_;
};
// ===================================================================


// ===================================================================

// E3Config

// required uint32 m = 1;
inline bool E3Config::has_m() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3Config::set_has_m() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3Config::clear_has_m() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3Config::clear_m() {
  m_ = 0u;
  clear_has_m();
}
inline ::google::protobuf::uint32 E3Config::m() const {
  return m_;
}
inline void E3Config::set_m(::google::protobuf::uint32 value) {
  set_has_m();
  m_ = value;
}

// optional double n = 2;
inline bool E3Config::has_n() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3Config::set_has_n() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3Config::clear_has_n() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3Config::clear_n() {
  n_ = 0;
  clear_has_n();
}
inline double E3Config::n() const {
  return n_;
}
inline void E3Config::set_n(double value) {
  set_has_n();
  n_ = value;
}

// optional double theta_e = 3;
inline bool E3Config::has_theta_e() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3Config::set_has_theta_e() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3Config::clear_has_theta_e() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3Config::clear_theta_e() {
  theta_e_ = 0;
  clear_has_theta_e();
}
inline double E3Config::theta_e() const {
  return theta_e_;
}
inline void E3Config::set_theta_e(double value) {
  set_has_theta_e();
  theta_e_ = value;
}

// optional double gamma_0_2 = 4;
inline bool E3Config::has_gamma_0_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void E3Config::set_has_gamma_0_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void E3Config::clear_has_gamma_0_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void E3Config::clear_gamma_0_2() {
  gamma_0_2_ = 0;
  clear_has_gamma_0_2();
}
inline double E3Config::gamma_0_2() const {
  return gamma_0_2_;
}
inline void E3Config::set_gamma_0_2(double value) {
  set_has_gamma_0_2();
  gamma_0_2_ = value;
}

// optional double delta_e = 5;
inline bool E3Config::has_delta_e() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void E3Config::set_has_delta_e() {
  _has_bits_[0] |= 0x00000010u;
}
inline void E3Config::clear_has_delta_e() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void E3Config::clear_delta_e() {
  delta_e_ = 0;
  clear_has_delta_e();
}
inline double E3Config::delta_e() const {
  return delta_e_;
}
inline void E3Config::set_delta_e(double value) {
  set_has_delta_e();
  delta_e_ = value;
}

// optional double r_e = 6;
inline bool E3Config::has_r_e() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void E3Config::set_has_r_e() {
  _has_bits_[0] |= 0x00000020u;
}
inline void E3Config::clear_has_r_e() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void E3Config::clear_r_e() {
  r_e_ = 0;
  clear_has_r_e();
}
inline double E3Config::r_e() const {
  return r_e_;
}
inline void E3Config::set_r_e(double value) {
  set_has_r_e();
  r_e_ = value;
}

// -------------------------------------------------------------------

// E3State_Particles

// required double a = 3;
inline bool E3State_Particles::has_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3State_Particles::set_has_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3State_Particles::clear_has_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3State_Particles::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline double E3State_Particles::a() const {
  return a_;
}
inline void E3State_Particles::set_a(double value) {
  set_has_a();
  a_ = value;
}

// required double ksi = 4;
inline bool E3State_Particles::has_ksi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3State_Particles::set_has_ksi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3State_Particles::clear_has_ksi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3State_Particles::clear_ksi() {
  ksi_ = 0;
  clear_has_ksi();
}
inline double E3State_Particles::ksi() const {
  return ksi_;
}
inline void E3State_Particles::set_ksi(double value) {
  set_has_ksi();
  ksi_ = value;
}

// required double eta = 5;
inline bool E3State_Particles::has_eta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3State_Particles::set_has_eta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3State_Particles::clear_has_eta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3State_Particles::clear_eta() {
  eta_ = 0;
  clear_has_eta();
}
inline double E3State_Particles::eta() const {
  return eta_;
}
inline void E3State_Particles::set_eta(double value) {
  set_has_eta();
  eta_ = value;
}

// -------------------------------------------------------------------

// E3State

// optional bool simulated = 1;
inline bool E3State::has_simulated() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3State::set_has_simulated() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3State::clear_has_simulated() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3State::clear_simulated() {
  simulated_ = false;
  clear_has_simulated();
}
inline bool E3State::simulated() const {
  return simulated_;
}
inline void E3State::set_simulated(bool value) {
  set_has_simulated();
  simulated_ = value;
}

// required double E = 3;
inline bool E3State::has_e() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3State::set_has_e() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3State::clear_has_e() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3State::clear_e() {
  e_ = 0;
  clear_has_e();
}
inline double E3State::e() const {
  return e_;
}
inline void E3State::set_e(double value) {
  set_has_e();
  e_ = value;
}

// required double phi = 4;
inline bool E3State::has_phi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3State::set_has_phi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3State::clear_has_phi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3State::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline double E3State::phi() const {
  return phi_;
}
inline void E3State::set_phi(double value) {
  set_has_phi();
  phi_ = value;
}

// repeated group Particles = 2 {
inline int E3State::particles_size() const {
  return particles_.size();
}
inline void E3State::clear_particles() {
  particles_.Clear();
}
inline const ::pb::E3State_Particles& E3State::particles(int index) const {
  return particles_.Get(index);
}
inline ::pb::E3State_Particles* E3State::mutable_particles(int index) {
  return particles_.Mutable(index);
}
inline ::pb::E3State_Particles* E3State::add_particles() {
  return particles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles >&
E3State::particles() const {
  return particles_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::E3State_Particles >*
E3State::mutable_particles() {
  return &particles_;
}

// -------------------------------------------------------------------

// E3PetscSolverConfig

// optional double tolerance = 1;
inline bool E3PetscSolverConfig::has_tolerance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3PetscSolverConfig::set_has_tolerance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3PetscSolverConfig::clear_has_tolerance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3PetscSolverConfig::clear_tolerance() {
  tolerance_ = 0;
  clear_has_tolerance();
}
inline double E3PetscSolverConfig::tolerance() const {
  return tolerance_;
}
inline void E3PetscSolverConfig::set_tolerance(double value) {
  set_has_tolerance();
  tolerance_ = value;
}

// optional double init_step = 2;
inline bool E3PetscSolverConfig::has_init_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3PetscSolverConfig::set_has_init_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3PetscSolverConfig::clear_has_init_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3PetscSolverConfig::clear_init_step() {
  init_step_ = 0;
  clear_has_init_step();
}
inline double E3PetscSolverConfig::init_step() const {
  return init_step_;
}
inline void E3PetscSolverConfig::set_init_step(double value) {
  set_has_init_step();
  init_step_ = value;
}

// -------------------------------------------------------------------

// E3Model

// required double time = 4;
inline bool E3Model::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void E3Model::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void E3Model::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void E3Model::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double E3Model::time() const {
  return time_;
}
inline void E3Model::set_time(double value) {
  set_has_time();
  time_ = value;
}

// required uint32 steps = 5;
inline bool E3Model::has_steps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void E3Model::set_has_steps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void E3Model::clear_has_steps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void E3Model::clear_steps() {
  steps_ = 0u;
  clear_has_steps();
}
inline ::google::protobuf::uint32 E3Model::steps() const {
  return steps_;
}
inline void E3Model::set_steps(::google::protobuf::uint32 value) {
  set_has_steps();
  steps_ = value;
}

// required .pb.E3Config pconfig = 1;
inline bool E3Model::has_pconfig() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void E3Model::set_has_pconfig() {
  _has_bits_[0] |= 0x00000004u;
}
inline void E3Model::clear_has_pconfig() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void E3Model::clear_pconfig() {
  if (pconfig_ != NULL) pconfig_->::pb::E3Config::Clear();
  clear_has_pconfig();
}
inline const ::pb::E3Config& E3Model::pconfig() const {
  return pconfig_ != NULL ? *pconfig_ : *default_instance_->pconfig_;
}
inline ::pb::E3Config* E3Model::mutable_pconfig() {
  set_has_pconfig();
  if (pconfig_ == NULL) pconfig_ = new ::pb::E3Config;
  return pconfig_;
}
inline ::pb::E3Config* E3Model::release_pconfig() {
  clear_has_pconfig();
  ::pb::E3Config* temp = pconfig_;
  pconfig_ = NULL;
  return temp;
}
inline void E3Model::set_allocated_pconfig(::pb::E3Config* pconfig) {
  delete pconfig_;
  pconfig_ = pconfig;
  if (pconfig) {
    set_has_pconfig();
  } else {
    clear_has_pconfig();
  }
}

// required .pb.E3State state = 2;
inline bool E3Model::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void E3Model::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void E3Model::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void E3Model::clear_state() {
  if (state_ != NULL) state_->::pb::E3State::Clear();
  clear_has_state();
}
inline const ::pb::E3State& E3Model::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::pb::E3State* E3Model::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::pb::E3State;
  return state_;
}
inline ::pb::E3State* E3Model::release_state() {
  clear_has_state();
  ::pb::E3State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void E3Model::set_allocated_state(::pb::E3State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// required .pb.E3PetscSolverConfig sconfig = 3;
inline bool E3Model::has_sconfig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void E3Model::set_has_sconfig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void E3Model::clear_has_sconfig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void E3Model::clear_sconfig() {
  if (sconfig_ != NULL) sconfig_->::pb::E3PetscSolverConfig::Clear();
  clear_has_sconfig();
}
inline const ::pb::E3PetscSolverConfig& E3Model::sconfig() const {
  return sconfig_ != NULL ? *sconfig_ : *default_instance_->sconfig_;
}
inline ::pb::E3PetscSolverConfig* E3Model::mutable_sconfig() {
  set_has_sconfig();
  if (sconfig_ == NULL) sconfig_ = new ::pb::E3PetscSolverConfig;
  return sconfig_;
}
inline ::pb::E3PetscSolverConfig* E3Model::release_sconfig() {
  clear_has_sconfig();
  ::pb::E3PetscSolverConfig* temp = sconfig_;
  sconfig_ = NULL;
  return temp;
}
inline void E3Model::set_allocated_sconfig(::pb::E3PetscSolverConfig* sconfig) {
  delete sconfig_;
  sconfig_ = sconfig;
  if (sconfig) {
    set_has_sconfig();
  } else {
    clear_has_sconfig();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_model_5fe3_2eproto__INCLUDED
